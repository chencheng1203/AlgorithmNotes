# 算法笔记（上）

## 链表

### 206. 反转链表

```c++
ListNode* reverseList(ListNode* head) {
    if (!head) return head;
    ListNode* pre = NULL;
    ListNode* p = head;
    ListNode* next = head->next;
    while(p){
        p->next = pre;
        pre = p;
        p = next;
        if (p) next = p->next;
    }
    return pre;
}
```

### 92. 反转链表II

描述：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

```c++
ListNode* reverseBetween(ListNode* head, int m, int n) {
    ListNode* p = head;
    ListNode* pre_last = NULL;
    for (int i = 0; i < m - 1; i++) {
        pre_last = p;
        p = p->next;
    }
    ListNode* end = p;
    // 开始翻转
    ListNode* pre = NULL;
    ListNode* next = p->next;
    for (int i = 0; i < n - m + 1; i++){
        p->next = pre;
        pre  = p;
        p = next;
        if (p) next = p->next;
    }
    // 串联起来
    if (pre_last) pre_last->next = pre;
    else head = pre;
    end->next = p;
    return head;
}
```

### 24. 两两交换链表中的节点

```c++
ListNode* swapPairs(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode* curr_p = head;
    ListNode* p_next = curr_p->next;
    ListNode* p_next_next = p_next->next;
    ListNode* pre_p;
    // exchange first 2 nodes
    curr_p->next = p_next_next;
    p_next->next = curr_p;
    ListNode* res_p = p_next;
    pre_p = curr_p;
    curr_p = p_next_next;
    while(curr_p && curr_p->next){
        p_next = curr_p->next;
        p_next_next = p_next->next;
        curr_p->next = p_next_next;
        p_next->next = curr_p;
        pre_p->next = p_next;
        pre_p = curr_p;
        curr_p = p_next_next;
    }
    return res_p;
}
```

### 142. 环形链表II

描述：链表中若没有环，则返回NULL，否则返回环的第一个入口节点

```c++
// 确定链表中环的节点个数 CircleNodeNum
// 若无环，那么return NULL
// 设置p0, p1指向头节点，p1先走 CircleNodeNum步，再一起走，相遇时即为环的入口
```

### 82. 删除链表中的重复元素

描述：给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 *没有重复出现* 的数字。

```c++
ListNode* deleteDuplicates(ListNode* head) {
    if (!head) return head;
    ListNode* dummy = new ListNode(-1);
    dummy->next = head;
    ListNode* not_repeat_p = dummy;  // 指向前一个不重复的元素
    ListNode* p = head;  // 遍历指针
    while(p){
        if (!p->next || p->val != p->next->val){
            not_repeat_p->next = p;
            not_repeat_p = p;
            p = p->next;
        }else{
            int curr_repeat_val = p->val;
            while(p && p->val == curr_repeat_val){
                p = p->next;
            }
            // 到了终点了
            if (!p) not_repeat_p->next = p;
        }
    }
    return dummy->next;
}
```

### 148. 链表的排序

使用归并排序的思想，并且实现以下两个环节

- 分割环节：找到当前链表的中点，并且从中点处将链表断开
  - 使用快慢指针的方法寻找中点
  - 找到中点slow后，执行slow.next = None，将链表切开
  - 递归的进行分割，输入当前链表左端点head和中心点slow的下一个节点temp
  - cut的终止条件为，当head.next == None时，说明只有一个节点了，直接返回该节点
- 合并merge环节
  - 双指针方法
  - 建立dumpy指针作为头部
  - 使用两个指针分别指向两个链表的头部，比较两个指针的大小。由小到大加入合并链表的头部

```c++
ListNode* sortList(ListNode* head) {
    if (!head || !head->next) return head;
    ListNode* fast = head->next;
    ListNode* slow = head;
    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }
    ListNode* right_p = slow->next;  // 右边的头节点
    slow->next = NULL;
    ListNode* left = sortList(head);
    ListNode* right = sortList(right_p);
    // 合并
    ListNode* dumpy = new ListNode(-1);
    ListNode* ans = dumpy;
    while(left && right){
        if (left->val < right->val){
            dumpy->next = left;
            left = left->next;
        }else{
            dumpy->next = right;
            right = right->next;
        }
        dumpy = dumpy->next;
    }
    dumpy->next = left ? left : right;
    return ans->next;
}
```



## 树

### 98. 验证二叉搜索树

- 方法一：中序遍历，看看得到的数组是否递增
- 方法二：带父节点的中序遍历

```c++
int pre = INT_MIN;
bool isValidBST(TreeNode* root){
    if (!root) return true;
    bool left = isValidBST(root->left);
    if (root->val <= pre) return false;
    pre = root->val;
    bool right = isValidBST(root->right);
    return left && right;
}
```

### 958. 验证完全二叉树

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

解：bfs 层级遍历，空节点也放到队列中，当遍历到的空节点时，说明后面遍历到的节点都得是空节点，否则不是完全二叉树

![complete-binary-tree-2](D:\学习\算法笔记\图片\complete-binary-tree-2.png)

**example**: queue: [1, 2, 3, 4, 5, null, 7]，由于NULL后面还有7，不满足条件

```c++
bool isCompleteTree(TreeNode* root) {
    // bfs
    if (!root) return true;
    queue<TreeNode*> queue;
    queue.push(root);
    bool catched = false;  //是否已经找到了第一个空元素
    while(queue.size()){
        TreeNode* curr = queue.front();
        queue.pop();
        if (catched && curr) return false;
        if (!curr){  // 遇到空节点
            catched = true;
            continue;
        }
        queue.push(curr->left);
        queue.push(curr->right);
    }
    return true;
}
```

### 173. 二叉搜索树迭代器

描述：实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。调用 `next()` 将返回二叉搜索树中的下一个最小的数。

解：使用栈存储树的左节点，每次取出栈顶元素，并且将该元素右节点的所有左节点存入栈中

### 236. 二叉树的最近公共祖先

```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) return root;
    if (root == p || root == q) return root;
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    if (!left) return right;
    if (!right) return left;
    return root;
}
```

### 669. 修剪二叉搜索树

描述：给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案

<img src="D:\学习\算法笔记\图片\trim2.jpg" alt="trim2" style="zoom:50%;" />



```c++
TreeNode* trimBST(TreeNode* root, int low, int high) {
    if (!root) return NULL;
    if (root->val < low) return trimBST(root->right, low, high);
    if (root->val > high) return trimBST(root->left, low, high);
    root->left = trimBST(root->left, low, high);
    root->right = trimBST(root->right, low, high);
    return root;
}
```

### 208. 实现Trie树

```c++
class Trie {
    public:
    /** Initialize your data structure here. */
    bool is_end = false;
    Trie* next[26];
    Trie() {
        // 初始化当前node的next数组
        memset(next, 0, sizeof(next));
    }
    /** Inserts a word into the trie. */
    void insert(string word) {
        Trie* node = this;
        for (char ch : word){
            if (!node->next[ch - 'a']){
                node->next[ch - 'a'] = new Trie();
            }
            node = node->next[ch - 'a'];
        }
        node->is_end = true;
    }

    /** Returns if the word is in the trie. */
    bool search(string word) {
        Trie* node = this;
        for (char ch : word){
            if (!node->next[ch - 'a']) return false;
            node = node->next[ch - 'a'];
        }
        return node->is_end ? true : false;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        Trie* node = this;
        for (char ch : prefix){
            if (!node->next[ch - 'a']) return false;
            node = node->next[ch - 'a'];
        }
        return true;
    }
};
```



## 回溯

### 17. 电话号码的字母组合

![17_telephone_keypad](D:\学习\算法笔记\图片\17_telephone_keypad.png)

**example**: digits = "23", outputs: ["ad","ae","af","bd","be","bf","cd","ce","cf"]

```c++
void dfs(string& digits, int index, string& path, std::map<char, string>& num2char, vector<string>& res){
    if (path.size() == digits.size()){
        res.push_back(path);
        return;
    }
    string code = num2char[digits[index]];
    // 做选择
    for (int j = 0; j < code.size(); j++){
        path += code[j];
        dfs(digits, index+1, path, num2char, res);
        path.pop_back();
    }
}
vector<string> letterCombinations(string digits) {
    vector<string> res;
    if (!digits.size()) return res;
    std::map<char, string> num2char = {std::pair('2', "abc"),
                                       std::pair('3', "def"),
                                       std::pair('4', "ghi"),
                                       std::pair('5', "jkl"),
                                       std::pair('6', "mno"),
                                       std::pair('7', "pqrs"),
                                       std::pair('8', "tuv"),
                                       std::pair('9', "wxyz")};
    string path="";
    dfs(digits, 0, path, num2char, res);
    return res;
}
```

### 22. 括号生成

在生成的合法的字符串括号中，左括号的数量一定要大于等于右括号的数量

```c++
void dfs(int left, int right, int n, string& path, vector<string>& res){
    if (path.size() == n*2){
        res.push_back(path);
        return;
    }
    // 生成左括号
    if (left < n){
        path += "(";
        dfs(left+1, right, n, path, res);
        path.pop_back();
    }
    // 生成右括号
    if (right < left){
        path += ")";
        dfs(left, right+1, n, path, res);
        path.pop_back();
    }
}
vector<string> generateParenthesis(int n) {
    string path = "";
    vector<string> res;
    dfs(0, 0, n, path, res);
    return res;
}
```

### 47. 全排列II

回溯算法中，若需要去重，一般需要排序 + 剪枝

```c++
void permute_core(vector<int>& nums, int size, int depth, vector<int>& path, vector<bool>& used, vector<vector<int>>& res){
    if (depth == size){
        res.push_back(path);
    }
    for (int i = 0; i < size; i++){
        if (used[i]) continue;
        if (i > 0 && nums[i] == nums[i - 1] && !used[i-1]) continue;
        if (!used[i]){
            path.push_back(nums[i]);
            used[i] = true;
            permute_core(nums, size, depth+1, path, used, res);
            used[i] = false;
            path.pop_back();
        }
    }
}
vector<vector<int>> permuteUnique(vector<int>& nums) {
    std::sort(nums.begin(), nums.end());
    int size = nums.size();
    vector<int> path;
    vector<bool> used(size, 0);
    vector<vector<int>> res;
    permute_core(nums, size, 0, path, used, res);
    return res;
}
```

### 78. 子集

```c++
void backtrack(vector<int>& nums, int index, vector<int>& path, vector<vector<int>>& ans){
    ans.push_back(path);
    for (int i = index; i < nums.size(); i++){
        path.push_back(nums[i]);
        backtrack(nums, i+1, path, ans); // 从下一个元素开始递归
        path.pop_back();
    }
}

vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> ans;
    vector<int> path;
    backtrack(nums, 0, path, ans);
    return ans;
}
```

### 51. N皇后

描述：**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

![queens](D:\学习\算法笔记\图片\queens.jpg)

```c++
bool NQueueIsValid(vector<string>& board, int row, int col){
    int cols = board[row].size();
    // 判断在该列上放置皇后是否合法
    for (int i = 0; i < row; i++){
        if (board[i][col] == 'Q')
            return false;
    }
    // 判断右上角放置皇后是否合法
    for (int i = row - 1, j = col + 1; i >= 0 &&  j < cols; i--, j++){
        if (board[i][j] == 'Q')
            return false;
    }
    // 判断左上角放置皇后是否合法
    for (int i = row - 1, j = col - 1; i >= 0 && j >=0; i--, j--){
        if (board[i][j] == 'Q')
            return false;
    }
    return true;
}
void NQueue_dfs(vector<string> board, int row, vector<vector<string>>& res){
    if (row == board.size()){
        res.push_back(board);
        return;
    }
    // 在该行的每一列上尝试放置皇后
    int n = board[row].size();
    for (int i = 0; i < n; i++){
        // 若不合法，则继续判断下一列
        if (!NQueueIsValid(board, row, i))
            continue;
        // 若是合法的，则填充该列[进行选择]，并且进入下一行
        board[row][i] = 'Q';
        NQueue_dfs(board, row+1, res);
        // 撤销选择
        board[row][i] = '.';
    }
}

vector<vector<string>> solveNQueens(int n){
    vector<string> board(n, string(n, '.'));
    vector<vector<string>> res;
    NQueue_dfs(board, 0, res);
    return res;
}
```

### 93. 复原IP地址

描述: 输入: s = "101023", 输出: ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

```c++
// nums: 分割了多少次了
// path: 存储有效的IP段
void backtrack(string s, int nums, vector<string>& path, vector<string>& res){
    if (nums == 4 && s.size() == 0){
        string temp = "";
        for (int i = 0; i < path.size(); i++){
            temp += path[i];
            if (i != path.size() - 1){
                temp += ".";
            }
        }
        res.push_back(temp);
        return;
    }
    if (nums == 4 && s.size() > 0) return;
    // 遍历字符串，并做截断处理，将剩余的字符串送入回溯函数进行递归
    for (int i = 0; i < 3; i++){
        if (i >= s.size()) continue;
        string left = s.substr(0, i+1);  // 左半部分
        string right = s.substr(i+1, s.size() - (i + 1));
        if (left == "0"){  // 只能以这个作为一段IP
            path.push_back(left);
            backtrack(right, nums+1, path, res);
            path.pop_back();
            break;  // 不能取以0开头的IP段
        }else{
            int str_num = stoi(left);
            if (str_num >= 0 && str_num <= 255){  // 判断有效性
                path.push_back(left);
                backtrack(right, nums+1, path, res);
                path.pop_back();
            }
        }
    }
}
vector<string> restoreIpAddresses(string s) {
    vector<string> path;
    vector<string> res;
    if (s.size() < 4 || s.size() > 12) return res;
    backtrack(s, 0, path, res);
    return res;
}
```

### 131.分割回文子串

描述：给你一个字符串`s`，将`s`分割成一些子串，使得每个子串都是回文串

```
输入：s = "aab"，输出： [["a","a","b"],["aa","b"]]
```

```c++
bool is_valid(string& s){
    int p1 = 0, p2 = s.size() - 1;
    while(p1 < p2){
        if (s[p1] != s[p2]) return false;
        p1++;
        p2--;
    }
    return false;
}
void backtrack(string& s, vector<string>& path, vector<vector<string>>& ans){
    if (s == ""){
        ans.push_back(path);
        return;
    }
    for (int i = 0; i < s.size(); i++){
        string left = s.substr(0, i + 1);
        if (!is_valid(left)) continue;
        string right = s.substr(i + 1, s.size() - (i + 1));
        path.push_back(left);
        backtrack(right, path, ans);
        path.pop_back();
    }
}
vector<vector<string>> partition(string s) {
    vector<string> path;
    vector<vector<string>> ans;
    backtrack(s, path, ans);
    return ans;
}
```



## 动态规划

### 5. 最长回文子串

状态定义：**dp[i] [j]**表示字符串s[i:j]是否为回文串

状态转移：

- 若dp[i+1] [j-1] == true && s[i] == s[j] 则dp[i] [j] = true
- 若s[i] == s[j] 且 j - i <= 1；则dp[i] [j] = true;
- 若dp[i] [j] == true，更新ans

```c++
string longestPalindrome(string s) {
    int sz = s.size();
    int start = sz - 1;
    int max_len = 1;
    vector<vector<bool>> dp(sz, vector<bool>(sz, false));
    // update dp table
    for (int i = sz-1; i >= 0; i--){
        for (int j = i; j < sz; j++){
            if (i == j){
                dp[i][j] = true;
                continue;
            }
            if (s[i] == s[j] && (j-i == 1)){
                dp[i][j] = true;
            }
            if (s[i] == s[j] && dp[i+1][j-1]){
                dp[i][j] = true;
            }
            if (dp[i][j] && (j - i + 1) > max_len){
                start = i;
                max_len = j - i + 1;
            }
        }
    }
    return s.substr(start, max_len);
}
```

### 516. 最长回文子序列

```c++
// dp[i][j] 表示s[i:j]区间的最长回文子序列
// if (i == j) dp[i][j] = 1;
// if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2
// else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
int longestPalindromeSubseq(string s) {
    int s_size = s.length();
    if (s_size < 2) return s_size;
    vector<vector<int>> dp(s_size+1, vector<int>(s_size+1, 0));
    for (int i = s_size; i > 0; i--){
        for (int j = i; j <= s_size; j++){
            if (i == j){
                dp[i][j] = 1;
                continue;
            }
            if (s[i - 1] == s[j - 1]){  // 相等的话，掐去头尾
                dp[i][j] = dp[i + 1][j - 1] + 2;  // 状态更新
            }else{
                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);  // 找俩边最长的
            }
        }
    }
    return dp[1][s_size];
}
```

### 198. 打家劫舍II

dp[i] 表示到第i户人家时，最多能偷的数量

状态转移 dp[i] = max(dp[i-1], dp[i-2] + nums[i])

```c++
int robCore(vector<int>& nums, int start, int end){
    int size = end - start + 1;
    if (size == 0) return 0;
    if (size == 1) return nums[start];
    if (size == 2) return std::max(nums[start], nums[start+1]);

    vector<int> dp(size, 0);
    dp[0] = nums[start];
    dp[1] = std::max(nums[start], nums[start+1]);
    for (int i = start + 2; i <= end; i++){
        dp[i-start] = std::max(nums[i] + dp[i-start-2], dp[i-start-1]);
    }
    return dp[end-start];
}

int rob(vector<int>& nums) {
    int size = nums.size();
    if (size == 0) return 0;
    if (size == 1) return nums[0];
    if (size == 2) return std::max(nums[0], nums[1]);
    return std::max(robCore(nums, 0, size-2), robCore(nums, 1, size-1));
}
```

###  Offer 60. n个骰子的点数

描述：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 
$$
dp[i][j]表示使用i个骰子，骰子之和等于j的方法数。\\
例如有3个骰子，其点数之和等于9的方法数为: \\
dp[3][9] = dp[2][3] + dp[2][4] + dp[2][5] + dp[2][6] + dp[2][7] + dp[2][8]\\
状态转移为: dp[i][j] \ += \ dp[i-1][j - k]\ for\ k\ in\ range(1, 6)
$$


```c++
vector<double> dicesProbability(int n) {
    // dp[i][j]: 一共有i个骰子，组成和为j的方案数
    vector<double> ans;
    long all_methods = pow(6, n);
    vector<vector<int>> dp(n + 1, vector<int>(6 * n + 1, 0));
    dp[0][0] = 1;  // 重要的状态初始化
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= 6 * n; j++){
            for (int k = 1; k <= 6; k++){
                if (j - k < 0) break;
                dp[i][j] += dp[i-1][j - k];
            }
        }
    }
    for (int i = n; i <= 6 * n; i++){
        ans.push_back(dp[n][i] / double(all_methods));
    }
    return ans;
}
```

### 120. 三角形的最小路径和

```c++
int minimumTotal(vector<vector<int>>& triangle){
    int triangle_size = triangle.size();
    vector<vector<int>> dp(triangle_size, vector<int>(triangle_size, 0));
    // 状态初始化
    dp[0][0] = triangle[0][0];
    for (int i = 1; i < triangle_size; i++){
        dp[i][0] = dp[i-1][0] + triangle[i][0];  // 头跟尾单独算
        for (int j = 1; j < i; j++){
            dp[i][j] = std::min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j];
        }
        dp[i][i] = dp[i-1][i-1] + triangle[i][i];  // 头跟尾单独算
    }
    int res = INT_MAX;
    for (int i = 0; i < triangle_size; i++){
        res = std::min(res, dp[triangle_size-1][i]);
    }
    return res;
}
```

### 152.乘积最大子数组

```c++
int tripleMin(int a1, int a2, int a3){
    return std::min(std::min(a1, a2), a3);
}
int tripleMax(int a1, int a2, int a3){
    return std::max(std::max(a1, a2), a3);
}

int maxProduct(vector<int>& nums) {
    int size = nums.size();
    int dp_min[size], dp_max[size];
    memset(dp_min, 0, sizeof(dp_min));
    memset(dp_max, 0, sizeof(dp_max));
    dp_min[0] = nums[0];
    dp_max[0] = nums[0];
    int res = nums[0];

    for (int i = 1; i < size; i++){
        dp_max[i] = tripleMax(dp_max[i-1]*nums[i], dp_min[i - 1]*nums[i], nums[i]);
        dp_min[i] = tripleMin(dp_max[i-1]*nums[i], dp_min[i - 1]*nums[i], nums[i]);
        res = std::max(res, dp_max[i]);
    }
    return res;
}
```

### 1143. 最长公共子串

```
dp[i][j] 表示 s1[:i] 与 s2[:j] 的最长公共子串，那么状态转移方程可以表示为
dp[i][j] = dp[i - 1][j - 1] + 1; // if s1[i] == s2[j]
else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
```

```c++
int longestCommonSubsequence(string s1, string s2){
    int m = s1.size(), n = s2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= m; i++){
        for (int j = 1; j <= n; j++){
            if (s[i - 1] == s[j - 1]){
                dp[i][j] = dp[i - 1][j - 1] + 1;
            }else{
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}
```

### 72. 编辑距离

描述：给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数 。你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

```
dp[i][j]: s[:i-1] 与 s[:j-1]的最短编辑距离
// 状态初始化
dp[0][j] = j; // 将一个空字符变成s[:j-1]需要的操作数为j，不断的插入
dp[i][0] = i; // 将一个字符串变成空字符串，不断的删除
// 状态转移
dp[i][j] = dp[i-1][j-1]; // s[i-1] = s[j-1]字符相等则不用进行操作
dp[i][j] = min(
			dp[i][j-1];  // 删除字符
			dp[i-1][j];  // 插入
			dp[i-1][j-1]; // 替换
) + 1;
```

```c++
int minDistance(string word1, string word2) {
    int N1 = word1.size(), N2 = word2.size();
    // dp[i][j] 表示将s[:i-1] 转换成 s[:j-1] 的最少操作数
    vector<vector<int>> dp(N1 + 1, vector<int>(N2 + 1, 0));
    // 状态初始化
    for (int i = 0; i <= N1; i++)
        dp[i][0] = i;
    for (int i = 0; i <= N2; i++)
        dp[0][i] = i;
    for (int i = 1; i <= N1; i++){
        for (int j = 1; j <= N2; j++){
            if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i-1][j-1];
            else{
                dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
            }
        }
    }
    return dp[N1][N2];
}
```

### 416. 分割等和子集

描述：给定一个数组，能否将数组中的元素分成两部分，使得这两部分的元素和相等

```c++
bool partition(vector<int>& nums){
    int sum = 0;
    int N = nums.size();
    for (int num : nums) sum += num;
    if (sum % 2) return false;  // 奇数直接返回
    int target = sum / 2;
    // dp[i][j] 使用前i个元素能否使得和为j
    vector<vector<int>> dp(N, vector<int>(target + 1, 0));
    // 状态初始化
    if (nums[0] <= target) dp[0][nums[0]] = true;
    for (int i = 1; i < N; i++){
        for (int j = 0; j <= target; j++){
            if (j-nums[i] < 0){
                dp[i][j] = dp[i-1][j];
                continue;
            }
            dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
        }
    }
    return dp[N - 1][target];
}
```

### 494. 目标和

描述：给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

```python
输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```

```c++
int findTargetSumWays(vector<int>& nums, int S) {
    int N = nums.size();
    // dp[i][j] 使用前 i 个数子，使得和为 j 的种类数
    vector<vector<int>> dp(N + 1, vector<int>(S + 1, 0));
    // 状态初始化
    dp[0][0] = 1;
    // 状态转移 dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]
    for (int i = 1; i <= N; i++){
        for (int j = 1; j <= S; j++){
            
        }
    }
}
```



### 1139. 最大的以1为边界的正方形

描述：给你一个由若干 `0` 和 `1` 组成的二维网格 `grid`，请你找出边界全部由 `1` 组成的最大 **正方形** 子网格，并返回该子网格中的元素数量。如果不存在，则返回 `0`。

```c++
int largest1BorderedSquare(vector<vector<int>>& grid) {
    int R = grid.size();
    if (!R) return 0;
    int C = grid[0].size();
    vector<vector<int>> up(R + 1, vector<int>(C + 1, 0));  // 以grid[i][j]作为右下角，该列上最长的1的延伸个数
    vector<vector<int>> left(R + 1, vector<int>(C + 1, 0));  // 以grid[i][j]作为右下角，该行的左侧最长的1的延伸个数
    int ans = 0;
    for (int i = 1; i <= R; i++){
        for (int j = 1; j <= C; j++){
            if (grid[i-1][j-1] == 1){
                // 更新up
                up[i][j] = up[i - 1][j] + 1;
                // 更新left
                left[i][j] = left[i][j - 1] + 1;
                int max_side = min(left[i][j], up[i][j]);
                for (int k = max_side; k >= 1; k--){
                    if (left[i - k + 1][j] >= k && up[i][j - k + 1] >= k){
                        ans = max(ans, k);
                        break;
                    }
                }
            }
        }
    }
    return ans * ans;
}
```

### 221. 最大的正方形

![max1grid](D:\学习\算法笔记\图片\max1grid.jpg)

```c++
int maximalSquare(vector<vector<char>>& matrix) {
        int R = matrix.size();
        if (!R) return 0;
        int C = matrix[0].size();
        vector<vector<int>> dp(R + 1, vector<int>(C + 1, 0));  // dp[i][j]表示以matrix[i - 1][j - 1]作为右下角正方形的最大边长
        int max_side = 0;
        for (int i = 1; i <= R; i++){
            for (int j = 1; j <= C; j++){
                if (matrix[i - 1][j - 1] == '1'){
                    dp[i][j] = min(dp[i - 1][j], min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
                    max_side = max(dp[i][j], max_side);
                }
            }
        }
        return max_side * max_side;
    }
```

### 486. 预测赢家

描述：给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

```
解：如果nums数组的长度为偶数，那么玩家1一定会获胜
dp[i][j] 表示 nums[i:j] 这个范围内，玩家1手里的分数比玩家2多的个数
如果拿了nums[i]，玩家2就会拿 dp[i+1][j]，于是玩家1比玩家2多nums[i] - dp[i+1][j]
如果拿了nums[j]，玩家2就会拿 dp[i][j-1]，于是玩家1比玩家2多nums[j] - dp[i][j-1]
如果子数组只有一个数字，即 j - i == 0，那么dp[i][j] = nums[i]
如果子数组只有两个数组，即 j - i == 1，那么dp[i][j] = abs(nums[i] - nums[j])
```

```c++
bool PredictTheWinner(vector<int>& nums) {
    int N = nums.size();
    vector<vector<int>> dp(N, vector<int, N>);
    for (int i = N - 1; i >= 0; i--){
        for (int j = i; j <= N; j++){
            if (i == j){
                dp[i][j] = nums[i]; 
                continue;
            }
            if (j - i == 1){
                dp[i][j] = abs(nums[i] - nums[j]);
                continue;
            }
            dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]);
        }
    }
    return dp[0][N - 1] >= 0;
}
```

### Offer14. 剪绳子

描述：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？

```
解：dp[i]表示当绳子长度为i时，剪成m段乘积的最大值
1. 状态初始化
dp[2] = 1;
2. 状态转移
对于长度为i的绳子，可以剪成长度为1，以及i - 1；但是当长度为1时，对乘积结果没有增益，所以开始剪是从长度为2开始
当只剪成2段时，这时候乘积为 k * (i - k)
当继续剪时，dp[i] = k * dp[i - k]
```

```c++
int cuttingRope(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    if (n == 2) return 1;
    int dp[n + 1];
    memset(dp, 0, sizeof(dp));
    dp[1] = 1;
    dp[2] = 1;
    for (int i = 3; i <= n; i++){
        for (int j = 2; j < i; j++){  // 从剪成长度为 2 开始剪
            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
        }
    }
    return dp[n];
}
```

### 1642.  统计字典序元音字符串的数目

描述：给你一个整数 `n`，请返回长度为 `n` 、仅由元音 (`a`, `e`, `i`, `o`, `u`) 组成且按 **字典序排列** 的字符串数量。

```c++
// int a, e, i, o, u
// a 表示以 a 开头的字符串的个数
// e 表示以 e 开头的字符串的个数
// ...
// a = a + e + i + o + u
// e = e + i + o + u
// ...
int countVowelStrings(int n) {
    int a = 1, e = 1, i = 1, o = 1, u = 1;
    for (int i = 1; i < n; i++){
        a = a + e + i + o + u;
        e = e + i + o + u;
        i = i + o + u;
        o = o + u;
        u = u;
    }
    return a + e + i + o + u;
}
```

### 322. 零钱兑换

描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

```
解：dp[i] 表示需要凑成金额为 i 时，所需要花费的最少的硬币数量
```

```c++
int coinChange(vector<int>& coins, int amount) {
    const int MAX = 99999;
    vector<int> dp(amount + 1, MAX);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++){
        for (int coin : coins){
            if (i - coin >= 0){
                dp[i] = min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] == MAX ? -1 : dp[amount];
}
```

### 518. 零钱兑换II

描述：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

```
解法一：当成背包问题处理
dp[i][j]：当使用前i枚硬币时，能够凑出总金额为 j 的次数
// 状态初始化
dp[i][0] = 1;
dp[0][j] = 0;  // 当不使用硬币时，能够凑出总金额为j的方法数
// 状态转移
dp[i][j] = dp[i - 1][j] + dp[i][j - coin]
```

```c++
int change(int amount, vector<int>& coins) {
    int N = coins.size();
    // 
    vector<vector<int>> dp(N + 1, amount + 1);
    // 初始化
    for (int i = 0; i < N; i++){
        dp[i][0] = 1;
    }
    for (int i = 1; i <= N; i++){
        for (int j = 1; j <= amount; j++){
            if (j - coins[i] < 0) dp[i][j] = dp[i - 1][j];
            else{
                // 如果使用这枚硬币的话，可以的方法数为dp[i][j - coins[i]]
                // 如果不使用这枚硬币，方法数为dp[i - 1][j]
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];
            }
        }
    }
    return dp[N][amount];
}
```

### 返回最长递增子数组

```c++
vector<int> get_LIS(vector<int>& nums){
    int N = nums.size();
    if (!N) return {};
    vector<int> dp(N, 1); // 保存 nums[i] 结尾的最长递增子序列的长度
    vector<vector<int>> per_LIS(N); // 保存以nums[i]结尾的最长递增子序列
    per_LIS[0] = {nums[0]};
    int max_len_index = 0;
    int max_len = 1;
    // 从索引1开始找
    for (int i = 1; i < N; i++){
        int curr_index = i;
        for (int j = 0; j < i; j++){
            if (nums[j] < nums[i]){
                dp[i] = max(dp[i], dp[j] + 1);
                if (dp[i] == dp[j] + 1)
                    curr_index = j;
            }
        }
        if (curr_index == i){
            per_LIS[i] = {nums[i]};
        }else{
            // curr_index 指向最后一个比 nums[i] 大的数
            for (int num : per_LIS[curr_index]){
                per_LIS[i].push_back(num);
            }
            per_LIS[i].push_back(nums[i]);
        }
        if (per_LIS[i].size() > max_len){
            max_len = per_LIS[i].size();
            max_len_index = i;
        }
    }
    return per_LIS[max_len_index];
}
```

### 买卖股票问题

#### 121. 买卖股票的最佳时机

描述：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```c++
int maxProfit(vector<int>& prices) {
    int N = prices.size();
    if (N < 2) return 0;
    int pre_min = prices[0];
    int max_profit = 0;
    for (int i = 1; i < N; i++){
        if (prices[i] < pre_min){
            pre_min = prices[i];
        }else{
            max_profit = max(max_profit, prices[i] - pre_min);
        }
    }
    return max_profit;
}
```

#### 122. 买卖股票的最佳时机 II

描述：给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

```c++
// dp[i][0] 表示第 i 天手里还有股票的最大利润
// dp[i][1] 表示第 i 天手里没有股票的最大利润
// dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]), 第 i 天手里有股票，要么是第 i - 1 天手里就有股票，要么是 i - 1 天手里没有股票，在 i 天买入了
// dp[i][1] = max(dp[i - 1][1], dp[i -1][0] + prices[i])
int maxProfit(vector<int>& prices) {
    int N = prices.size();
    if (N < 2) return 0;
    vector<vector<int>> dp(N, vector<int>(2, 0));
    dp[0][0] = -prices[0];
    dp[0][1] = 0;
    for (int i = 1; i < N; i++){
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
        dp[i][1] = max(dp[i - 1][1], dp[i -1][0] + prices[i]);
    }
    return dp[N -1][1];
}
```

#### 714. 买卖股票的最佳时机含手续费

描述：给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。

```c++
int maxProfit(vector<int>& prices, int fee) {
    int N = prices.size();
    if (N < 2) return 0;
    vector<vector<int>> dp(N, vector<int>(2, 0));
    // dp[i][0] 手里有股票的最大利润
    // dp[i][1] 手里没有股票的最大利润
    // 在买入的时候算手续费
    dp[0][0] = -prices[0] - fee;
    dp[0][1] = 0;
    for (int i = 1; i < N; i++){
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i] - fee);
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
    }
    return dp[N - 1][1];
}
```

#### 309. 买卖股票的最佳时期含冷冻期

描述：给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

```c++
int maxProfit(vector<int>& prices) {
    int N  = prices.size();
    if (N < 2) return 0;
    // dp[i][0] 第 i 天手里有股票的最大利润
    // dp[i][1] 第 i 天手里没有股票，且不再冻结期的最大利润
    // dp[i][2] 第 i 天以后处于冻结期的最大利润（说明 i 天把股票卖了）
    vector<vector<int>> dp(N, vector<int>(3, 0));
    dp[0][0] = -prices[0];
    dp[0][1] = 0;
    dp[0][2] = 0;
    for (int i = 1; i < N; i++){
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][2]);  // 冻结期
        dp[i][2] = dp[i - 1][0] + prices[i];  // 前一天有股票，这一天给卖了
    }
    return max(dp[N - 1][1], dp[N - 1][2]);
}
```

### 139. 单词拆分

```c++
// dp[i] 表示 s 的前 i 个字符是否能够拆分
// 对于字符串 s = "leetcode", 索引位置 i = 3，需要再加上一层循环，判断s[0:i]位置上是否存在点 j, 使得 s[0:j] 能够被拆分并且 s[j : i] 出现在wordDict中
bool wordBreak(string s, vector<string>& wordDict) {
    unordered_set<string> sets(wordDict.begin(), wordDict.end());
    vector<bool> dp(s.size() + 1);
    dp[0] = 1;
    for (int i = 1; i <= s.size(); i++){
        for (int j = 0; j < i; j++){ 
            string left = s.substr(j, i - j + 1);
            if (dp[j] && sets.count(left)){
                dp[i] = 1;
                break;
            }
        }
    }
    return dp[s.size()];
}
```

### 279. 完全平方数

描述：给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

```c++
int numSquares(int n){
    vector<int> dp(n + 1);
    for (int i = 1; i <= n; i++){
        dp[i] = i;
        for (int j = 1; i - j * j >= 0; j++){
            dp[i] = min(dp[i], dp[i - j * j] + 1);
        }
    }
    return dp[n];
}
```

### 91. 解码方法

```
描述：一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价，给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 
```

```python
解：dp[i]表示字符串 s[:i] 的解码方法数
当前字符为 a = s[i]，当前字符和它前一个字符在一起 b = s[i -1: i]
可得状态转移方程：
dp[i] = dp[i - 1]; a是合法的，即 1 <= a <= 9
dp[i] = dp[i - 2]; b是合法的，即 10 <= b <= 26
dp[i] = dp[i - 1] + dp[i - 2], a, b 都是合法的
```

### 377. 组合总数

描述：给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

```
输入：nums = [1,2,3], target = 4
输出：7
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
```

```c++
解：dp[i]表示当总和为 i 时的方法数
nums = [1, 2, 3]
dp[6] = dp[6 - 1] + dp[6 - 2] + dp[6 - 3]

int combinationSum4(vector<int>& nums, int target) {
    vector<int> dp(target + 1); // dp[i] 表示当目标数为 i 时元素组合的方法数
    dp[0] = 1;
    for (int i = 1; i <= target; i++){
        for (int num : nums){
            if (i - num >= 0){
                dp[i] += dp[i - num];
            }
        }
    }
    return dp[target];
}
```

### 983. 最低票价

描述：在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。

火车票有三种不同的销售方式：

一张为期一天的通行证售价为 costs[0] 美元；
一张为期七天的通行证售价为 costs[1] 美元；
一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。

```c++
// dp[i] 表示在第 i 天旅行的最小票价
// dp[i] = min(dp[i - 1] + costs[0], 单天的票
//			  dp[i - 7] + costs[1], 买7天的票
//             dp[i - 30] + costs[2])， 买30天的票
int mincostTickets(vector<int>& days, vector<int>& costs) {
    int last_day = days[days.size() - 1];
    vector<int> dp(last_day + 1);
    int index = 0;  // index 表示当前遍历到哪一天了
    for (int i = 1; i <= last_day; i++){
        if (i != days[index]){  // 这一天没有旅行
            dp[i] = dp[i - 1];  // 花的钱跟前一天一样
        }else{
            dp[i] = min(min(dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1]), dp[max(0, i - 30)] + costs[2]));
        }
    }
    return dp[last_day];
}
```

### 413. 等差数列的长度

```
A = [1, 2, 3, 4]
返回: 3。 A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。
```

```c++
int numberOfArithmeticSlices(vector<int>& nums) {
    int N = nums.size();
    vector<int> dp(N);  // dp[i] 表示以 nums[i] 结尾的等差数列的长度
    int ans = 0;
    for (int p1 = 0, p2 = 2; p2 < N; p1++, p2++){
        int mid = p1 + 1;
        if (nums[p2] - nums[mid] == nums[mid] - nums[p1]){
            dp[p2] += dp[p2 - 1] + 1;
        }
        ans += dp[p2];
    }
    return ans;
}
```

### 357. 计算各个位数上不同数字的个数

描述：给定一个**非负**整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。

```c++
// 当 n == 1 时，数字可以选择 0 - 9，一共有10种选择
// 当 n == 2 时，个位上的数字可以选择 0 - 9，但是由于十位上已经选择了数字，个位上的数字不能与十位上的数字相同，故只有 9 种
// 由以上分析可是 n == 2 时不同的数字的个数为 当 n == 1 的个数 加上 两位数字的个数，即 10 + 9 * 9 = 91
// 当 n == 3 时，10 + 9 * 9 + 9 * 9 * 8；

```

### 1269. 停留在原地的方法数

描述：有一个长度为 `arrLen` 的数组，开始有一个指针在索引 `0` 处。每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。

```c++
// 定义状态
// dp[i][j] 表示当走了 i 步以后，停在索引 j 处的方法数的数目
// 状态初始化
// dp[0][0] = 1 当走了 0 步后，停在索引 0 处的方法数很明显是 1
// dp[i][j] = dp[i - 1][j] (停在原地不动)
// dp[i][j] = dp[i - 1][j - 1] (从左边过来)
// dp[i][j] = dp[i - 1][ j + 1] (从右边过来)
// dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j + 1]
```

```c++
int numWays(int steps, int arrLen) {
    vector<vector<int>> dp(steps + 1, vector<int>(max_len));
    dp[0][0] = 1;
    for (int i = 1; i <= steps; i++){
        for (int j = 0; j < arrLen; j++){
            dp[i][j] = dp[i - 1][j];
            if (j - 1 >= 0){
                dp[i][j] += dp[i - 1][j - 1];
            }
            if (j + 1 < arrLen){
                dp[i][j] += dp[i - 1][j + 1];
            }
        }
    }
    return dp[steps][0];
}
```



## 二分查找（滑动串口）

### 3. 无重复字符的最长子串

描述：给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**example: **s = "abcabcbb"，因为无重复字符的最长子串是 "abc"，所以其长度为 3

```c++
int lengthOfLongestSubstring(string s) {
    std::map<char, int> windows;
    int p1 = 0, p2 = 0;
    int res = 0;
    while(p2 < s.size()){
        char p2_char = s[p2];
        windows[p2_char]++;
        p2++;
        while(windows[p2_char] > 1){
            char p1_char = s[p1];
            windows[p1_char]--;
            p1++;
        }
        res = std::max(res, p2 - p1);
    }
    return res;
}
```

### 11. 盛最多水的容器

![question_11](D:\学习\算法笔记\图片\question_11.jpg)

```c++
int maxArea(vector<int>& height) {
    int sz = height.size();
    if (!sz) return 0;
    int res = 0;
    // 双指针，高度值小的指针向中间移动
    int p1 = 0, p2 = sz - 1;
    while(p1 < p2){
        res = std::max(std::min(height[p1], height[p2]) * (p2 - p1), res);
        if (height[p1] > height[p2]) p2--;
        else p1++;
    }
    return res;
}
```

### Offer 04. 二维数组中的查找

描述：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

````c++
bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
    if (matrix.size() == 0) return false;
    int rows = matrix.size();
    int cols = matrix[0].size();
    int i = 0, j = cols - 1;  // 从右上角开始搜索
    while(i <= rows - 1 && j >= 0){
        if (matrix[i][j] == target) return true;
        if (matrix[i][j] > target){
            j--;
        }else{
            i++;
        }
    }
    return false;
}
````

### 76. 最小覆盖子串

描述： 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

```c++
string minWindow(string s, string t){
    int min_len = INT_MAX;
    int start = -1;
    map<char, int> windows, need;
    for (char ch : t){
        need[ch]++;
    }
    int p0 = 0, p1 = 0;
    int valid = 0;  // 满足条件的个数
    int N = s.size();
    while(p1 < N){
        int end_ch = s[p1];
        if (need.count(end_ch)){
            windows[end_ch]++;
            if (windows[end_ch] == need[end_ch]){
                valid++;
            }
        }
        while(valid == need.size()){
            if (p1 - p0 + 1 < min_len){
                start = p0;
                min_len = p1 - p0 + 1;
            }
            char front_ch = s[p0];
            if (need.count(front_ch)){
                if (windows[front_ch] == need[front_ch]){
                    valid--;
                }
                windows[front_ch]--;
            }
            p0++;
        }
        p1++;
    }
    if (start == -1) return "";
    return s.substr(start, min_len);
}
```

### 33. 搜索旋转数组

描述：整数数组 `nums` 按升序排列，数组中的值 **互不相同** ，在传递给函数之前，`nums` 在预先未知的某个下标 **k**进行了旋转，给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的索引，否则返回 `-1` 。

解：根据 nums[mid] 与 nums[p0] 的关系判断哪个部分是已经排好了序的

```c++
int search(vector<int>& nums, int target){
    int p0 = 0, p1 = nums.size() - 1;
    while(p0 <= p1){
        int mid = p0 + ((p1 - p0) >> 1);
        if (nums[mid] == target) return mid;
        if (nums[mid] >= nums[p0]){  // 左边是有序的
            if (target >= nums[p0] && target < nums[mid]){
                p1 = mid - 1;
            }else{
                p0 = mid + 1;
            }
        }else{  // 右边是有序的
            if (target > nums[mid] && target <= nums[p1]){
                p0 = mid + 1;
            }else{
                p1 = mid - 1;
            }
        }
    }
    return -1;
}
```

### 81.收缩旋转排序数组II

### 1052. 爱生气的书店老板

描述：今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。

在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。

书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。

请你返回这一天营业下来，最多有多少客户能够感到满意的数量。

```
解：统计在哪个X窗口内，使用滑动窗口最划算
```

```c++
int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int X){
    int sum = 0;
    int N = customers.size();
    for (int i = 0; i < N; i++){
        if (grumpy[i] == 0)  // 不生气
            sum += customers[i];
    }
    // 计算在哪个窗口内使用最划算
    int max_diff = 0;
    int use_cus = 0;
    int not_use_cus = 0;
    for (int i = 0; i < X; i++){
        use_cus += customers[i];
        if (grumpy[i] == 0)
            not_use_cus += customers[i];
    }
    max_diff = use_cus - not_use_cus;
    for (int i = X; i < N; i++){
        // 减去移出窗口的值
        use_cus -= customers[i - X];
        if (grumpy[i - X] == 0) not_use_cus -= customers[i - X];
        // 窗口括进来的数
        use_cus += customers[i];
        if (grumpy[i] == 0) not_use_cus += customers[i];
        max_diff = max(max_diff, use_cus - not_use_cus;)
    }
    return sum + max_diff;
}
```

###  220. 存在重复的元素

描述：给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k

```c++
bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
    int N = nums.size();
    set<long> wins;
    for (int i = 0; i < N; i++){
        auto p = wins.lower_bound(long(nums[i]) - t);  // 寻找wins中大于nums[i] - t的下标
        if ((p != wins.end() && *p <= long(nums[i]) + t)) return true;
        wins.insert(nums[i]);
        if (i >= k) wins.erase(nums[i - k]);
    }
    return false;
}
```

## 贪心

### 1014. 最佳观光组合

描述：给你一个正整数数组 `values`，其中 `values[i]` 表示第 `i` 个观光景点的评分，并且两个景点 `i` 和 `j` 之间的 **距离** 为 `j - i`，一对景点（i < j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。返回一对观光景点能取得的最高分

**example:** values = [8,1,5,2,6],  i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11

解：题目要求values[i] + values[j] - (j - i)，可以变形为 values[i] + i + values[j] - j 的最大值，分成values[i] + i 和 values[j] - j 两部分各自最大即可

``````c++
int maxScoreSightseeingPair(vector<int>& values) {
    int N = values.size();
    int left = values[0], ans = 0;
    for (int i = 1; i < N; i++){
        ans = max(ans, left + values[i] - i);  
        left = max(left, values[i] + i);  // 动态维护values[i] + i
    }
    return ans;
}
``````

### 55. 跳跃游戏

描述：给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。

解：每一步都计算在该一步最多能够跳到的位置，若最远能够跳到的位置farthest等于当前位置，则说明卡住了，返回false

```c++
bool canJump(vector<int>& nums) {
    int N = nums.size();
    int farthest = 0;
    for (int i = 0; i < N - 1; i++){
        farthest = max(farthest, nums[i] + i);
        if (farthest <= i) return false;
    }
    return farthest >= n-1;
}
```

### 56. 合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

```c++
static bool compare(vector<int>& A, vector<int>& B){
    if (A[0] != B[0])
        return A[0] < B[0];
    else
        return A[1] < B[1];
}
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    vector<vector<int>> ans;
    if (!intervals.size()) return ans;
    // 按起点位置排序
    sort(intervals.begin(), intervals.end(), compare);
    int start = intervals[0][0], end = intervals[0][1];
    int i = 1;
    while(i < intervals.size()){
        if (intervals[i][0] <= end){  // 说明有重叠
            end = max(end, intervals[i][1]);  // 直接更新尾节点
        }else{
            ans.push_back({start, end});
            start = intervals[i][0];
            end = intervals[i][1];
        }
        i++;
    }
    ans.push_back({start, end}); // 漏网之鱼
    return ans;
}
```

### 57. 插入区间

给你一个 **无重叠的** *，*按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

```c++
vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
    vector<vector<int>> res;
    int p = 0, size = intervals.size();
    // 被插入的在区间的右侧
    while(p < size && intervals[p][1] < newInterval[0]){
        res.push_back(intervals[p]);
        p++;
    }
    if (p == size){
        res.push_back(newInterval);
        return res;
    }
    // 被插入的在区间的左侧
    if (newInterval[1] < intervals[p][0]){
        res.push_back(newInterval);
    }else{  // 区间有交集
        int start = std::min(intervals[p][0], newInterval[0]);
        // 寻找起点大于newInterval的终点，前一个即为合并区间的终点
        p++;
        while(p < size && intervals[p][0] <= newInterval[1]) p++;
        p--;
        int end = std::max(newInterval[1], intervals[p][1]);
        res.push_back({start, end});
        // 将剩余的括进来
        p++;
    }
    while(p < size){
        res.push_back(intervals[p]);
        p++;
    }
    return res;
}
```

### 763. 划分字符区间

描述：字符串 `S` 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

```c++
// 贪心解法: 使用hash存储每个字符最后一次出现的位置
vector<int> partitionLabels(string S) {
    int N = S.size();
    map<char, int> hash;
    vector<int> ans;
    for (int i = 0; i < N; i++){
        hash[S[i]] = i;  // hash存着每个字符最后一次出现的位置
    }
    int start = 0, end = 0;
    for (int i = 0; i < N; i++){
        // 当前字符最后一次出现的位置
        end = max(end, hash[S[i]]);  // max 操作说明了当前字符前面的字符的最后一次出现的索引位置
        // 若当前遍历的位置就是当前字符最后一次出现的位置，那么贪心的进行选择
        if (end == i){
            ans.push_back(end - start + 1);
            start = i + 1;
        }
    }
    return ans;
}
```

### 670. 最大交换

描述：给定一个非负整数，你**至多**可以交换一次数字中的任意两位。返回你能得到的最大值。

```c++
int maximumSwap(int num) {
    string s = to_string(num);
    int N = s.size();
    vector<char> right_max(N);
    // 从后向前遍历，寻找比当前数大的数
    int max_num = s[N - 1];
    right_max[N - 1] = '#';
    for (int i = N - 2; i >= 0; i--){
        if (s[i] >= max_num){
            right_max[i] = '#';  // # 表示右边没有比当前的要大的
            max_num = s[i];
        }else{
            right_max[i] = max_num;
        }
    }
    // 从前向后遍历
    for(int i = 0; i < N; i++){
        char curr = s[i];
        if (right_max[i] == '#'){
            continue;
        }else{
            // 从后向前找出需要交换的数
            s[i] = right_max[i];
            int j = N - 1;
            for (; j >= 0 && s[j] != right_max[i]; j--);
            s[j] = curr;
            return stoi(s);
        }
    }
    return stoi(s);
}
```

### 134. 加油站

描述：在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

```c++
// canFinish函数的功能为从 index 处的加油站出发能否环绕一圈
bool canFinish(vector<int>& gas, vector<int>& cost, int index){
    int N = gas.size();
    int gas_has = gas[index];
    int count = 0;
    while(true){
        if (count == N) return true;
        int gas_cost = cost[index];
        if (gas_has < gas_cost) return false;
        index = (index + 1) % N;
        gas_has = gas_has - gas_cost + gas[index];
        count++;
    }
    return false;
}
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    int N = gas.size();
    for (int i = 0; i < N; i++){
        if (canFinish(gas, cost, i)) return i;
    }
    return -1;
}
```

### 560. 和为k的子数组

```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

```c++
int subarraySum(vector<int>& nums, int k) {
    // hash + 前缀和
    unordered_map<int,  int> hash;  // hash[i] 表示前缀和为i出现的次数
    hash[0] = 1;  // 初始化
    int ans = 0;
    int pre_sum = 0;
    for (int i = 0; i < nums.size(); i++){
        pre_sum += nums[i];
        int target = pre_sum - k;
        if (hash.count(target)){
            ans += hash[target];
        }
        hash[pre_sum]++;
    }
    return ans;
}
```

### 1300. 转变数组后最接近目标值的数组和

描述：给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数value，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。

如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。请注意，答案不一定是 arr 中的数字。

```c++
// 排序 + 前缀和 + 搜索
int findBestValue(vector<int>& arr, int target) {
    sort(arr.begin(), arr.end());
    int presum = 0;
    int N = arr.size();
    int sum = 0;
    int i = 0;
    for (; i < N; i++){
        sum = presum + arr[i] * (N - i);
        if (sum > target) break;
        presum += arr[i];
    }
    if (i == N) return arr[N - 1];
    int remain_sum = target - presum;
    int lo = remain_sum / (N - i);
    int hi = lo + 1;
    int lo_sum = presum + lo * (N - i);
    int hi_sum = presum + hi * (N - i);
    if (abs(lo_sum - target) < abs(hi_sum - target)){
        return lo;
    }
    return hi;
}
```

### 递增三元组的数量

描述：给定一个数组nums，统计满足 0 <= i < j < k， nums[i] < nums[j] < nums[j] 的数量

```c++
// 递增的三元组的数量
int triple_increasing_nums(vector<int>& nums){
    // 以当前元素为中心点，分别寻找其左边小于该值的元素的个数和右边大于该值的元素的个数
    int ans = 0;
    for (int i = 0; i < nums.size(); i++){
        // 以该点为中心点查找左边比它小的和右边比它大的元素的个数
        int left_count = 0, right_count = 0;
        int left = i - 1, right = i + 1;
        // 左边
        while(left >= 0){
            if (nums[left] < nums[i]) left_count++;
            left--;
        }
        // 右边
        while(right < nums.size()){
            if (nums[right] > nums[i]) right_count++;
            right++;
        }
        ans += (left_count * right_count);
    }
    return ans;
}
```

